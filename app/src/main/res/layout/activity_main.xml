<?xml version="1.0" encoding="utf-8"?>
package com.example.whatsappcleanerpro

import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import androidx.work.*
import java.io.File
import java.util.concurrent.TimeUnit

class MainActivity : AppCompatActivity() {

    private lateinit var tvStorageInfo: TextView
    private lateinit var tvStatus: TextView
    private lateinit var btnCleanCache: Button
    private lateinit var btnAutoClean: Button

    private val workTag = "whatsapp_auto_clean"
    private val PERMISSION_REQUEST_CODE = 1001

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        tvStorageInfo = findViewById(R.id.tvStorageInfo)
        tvStatus = findViewById(R.id.tvStatus)
        btnCleanCache = findViewById(R.id.btnCleanCache)
        btnAutoClean = findViewById(R.id.btnAutoClean)

        updateStorageInfo()
        updateAutoCleanButton()

        btnCleanCache.setOnClickListener {
            if (checkAndRequestPermissions()) {
                cleanWhatsAppCache()
            }
        }

        btnAutoClean.setOnClickListener {
            toggleAutoClean()
        }
    }

    private fun checkAndRequestPermissions(): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val permissions = arrayOf(
                android.Manifest.permission.READ_EXTERNAL_STORAGE,
                android.Manifest.permission.WRITE_EXTERNAL_STORAGE
            )
            val needed = permissions.filter {
                checkSelfPermission(it) != PackageManager.PERMISSION_GRANTED
            }
            return if (needed.isNotEmpty()) {
                requestPermissions(needed.toTypedArray(), PERMISSION_REQUEST_CODE)
                false
            } else {
                true
            }
        }
        return true
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == PERMISSION_REQUEST_CODE) {
            if (grantResults.isNotEmpty() && grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                cleanWhatsAppCache()
            } else {
                tvStatus.text = "Permissions denied. Cannot clean cache."
            }
        }
    }

    private fun updateStorageInfo() {
        val sizeBytes = getWhatsAppCacheSize()
        val sizeMb = sizeBytes / (1024.0 * 1024.0)
        tvStorageInfo.text = "Storage Used by WhatsApp Files: %.2f MB".format(sizeMb)
    }

    private fun getWhatsAppCacheSize(): Long {
        val basePaths = listOf(
            Environment.getExternalStorageDirectory().absolutePath + "/WhatsApp/Media",
            Environment.getExternalStorageDirectory().absolutePath + "/WhatsApp/Cache"
        )
        var totalSize = 0L
        for (path in basePaths) {
            totalSize += getFolderSize(File(path))
        }
        return totalSize
    }

    private fun getFolderSize(dir: File): Long {
        if (!dir.exists() || !dir.isDirectory) return 0L
        var size = 0L
        val files = dir.listFiles() ?: return 0L
        for (file in files) {
            size += if (file.isDirectory) getFolderSize(file) else file.length()
        }
        return size
    }

    private fun cleanWhatsAppCache() {
        tvStatus.text = "Cleaning WhatsApp cache..."
        val cleaned = deleteWhatsAppCache()
        if (cleaned) {
            tvStatus.text = "WhatsApp cache cleaned successfully."
        } else {
            tvStatus.text = "No WhatsApp cache files found or failed to clean."
        }
        updateStorageInfo()
    }

    private fun deleteWhatsAppCache(): Boolean {
        val basePaths = listOf(
            Environment.getExternalStorageDirectory().absolutePath + "/WhatsApp/Media",
            Environment.getExternalStorageDirectory().absolutePath + "/WhatsApp/Cache"
        )
        var anyDeleted = false
        for (path in basePaths) {
            val deleted = deleteFolderContents(File(path))
            if (deleted) anyDeleted = true
        }
        return anyDeleted
    }

    private fun deleteFolderContents(dir: File): Boolean {
        if (!dir.exists() || !dir.isDirectory) return false
        var deletedAny = false
        val files = dir.listFiles() ?: return false
        for (file in files) {
            deletedAny = if (file.isDirectory) {
                val innerDeleted = deleteFolderContents(file)
                if (file.delete()) true else innerDeleted
            } else {
                file.delete() || deletedAny
            } || deletedAny
        }
        return deletedAny
    }

    private fun toggleAutoClean() {
        val workManager = WorkManager.getInstance(applicationContext)
        val isEnabled = isAutoCleanEnabled()
        if (isEnabled) {
            workManager.cancelAllWorkByTag(workTag)
            tvStatus.text = "Auto clean disabled."
        } else {
            val constraints = Constraints.Builder()
                .setRequiresCharging(false)
                .setRequiresBatteryNotLow(true)
                .build()
            val cleanRequest = PeriodicWorkRequestBuilder<AutoCleanWorker>(1, TimeUnit.DAYS)
                .setConstraints(constraints)
                .addTag(workTag)
                .build()
            workManager.enqueueUniquePeriodicWork(
                workTag,
                ExistingPeriodicWorkPolicy.REPLACE,
                cleanRequest
            )
            tvStatus.text = "Auto clean enabled: will run daily."
        }
        updateAutoCleanButton()
    }

    private fun updateAutoCleanButton() {
        btnAutoClean.text = if (isAutoCleanEnabled()) {
            "Disable Auto Clean"
        } else {
            "Enable Auto Clean (Daily)"
        }
    }

    private fun isAutoCleanEnabled(): Boolean {
        val workManager = WorkManager.getInstance(applicationContext)
        val statuses = workManager.getWorkInfosByTag(workTag).get()
        return statuses.any { it.state == WorkInfo.State.ENQUEUED || it.state == WorkInfo.State.RUNNING }
    }
}
